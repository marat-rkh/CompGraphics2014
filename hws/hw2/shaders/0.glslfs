#version 130

in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 Tangent_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace;

out vec3 color;

uniform sampler2D myTextureSampler;
uniform sampler2D myTextureSamplerNormal;
uniform vec3 lightPos;

vec3 CalcBumpedNormal() {
    vec3 Normal = normalize(Normal_cameraspace);
    vec3 Tangent = normalize(Tangent_cameraspace);
    Tangent = normalize(Tangent - dot(Tangent, Normal) * Normal);
    vec3 Bitangent = cross(Tangent, Normal);
    vec3 BumpMapNormal = texture(myTextureSamplerNormal, UV).xyz;
    BumpMapNormal = 2.0 * BumpMapNormal - vec3(1.0, 1.0, 1.0);
    vec3 NewNormal;
    mat3 TBN = mat3(Tangent, Bitangent, Normal);
    NewNormal = TBN * BumpMapNormal;
    NewNormal = normalize(NewNormal);
    return NewNormal;
}

void main() {
    vec3 LightColor = vec3(1,1,1);
    float LightPower = 500.0f;

    vec3 MaterialDiffuseColor = texture2D( myTextureSampler, UV ).rgb;
    vec3 MaterialAmbientColor = vec3(0.5,0.5,0.5) * MaterialDiffuseColor;
    vec3 MaterialSpecularColor = vec3(0.6, 0.6, 0.6);

    float distance = length(lightPos - Position_worldspace);

    // vec3 n = normalize(Normal_cameraspace);
    vec3 n = CalcBumpedNormal();
    vec3 l = normalize( LightDirection_cameraspace );
    float cosTheta = clamp( dot( n,l ), 0,1 );

    vec3 E = normalize(EyeDirection_cameraspace);
    vec3 R = reflect(-l,n);
    float cosAlpha = clamp( dot( E,R ), 0,1 );

    color = MaterialAmbientColor +
            MaterialDiffuseColor * LightColor * LightPower * cosTheta / (distance*distance) +
            MaterialSpecularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);
}
